zh-CN:
  mongoid:
      models:
        category: "分类"
        product: "商品"
        variant: "版本"
        cart: "购物车"
        customer: "客户"
        supplier: "供应商"
        employee: "员工"
        order: "订单"
        shipping_method: "配送方式"
        shipping_zone: "配送区域"
        shipping_rate: "配送费用"
        customer_group: "客户组"
        page: "网店页面"
        article: "网店内容"
        guest_book: "网店留言"
        review: "评论"
      attributes:
        category:
          actived: '是否激活'
          parent: '父分类'
          name: '分类名称'
          desc: '分类描述'
        product:
          actived: "是否激活"
          categories: "所属分类"
          spu: "商品编码"
          name: "商品名称"
          strapline: "副标题"
          desc: "商品描述"
          summary: '摘要'
          url: "下载"
          img: "商品图片"
          featured: "推荐"
          customer_group: "客户组"
          supplier: "供货商"
          seq: "排序"
          reviewed: "可否评论"
          spec: "规格"
          desc: "描述"
          comment: "评论"
          write_first: "成为第一个评论的人!"
          write_comment: "写下您的评论!"
        variant:
          actived: "是否激活"
          customer_group: "客户组"
          sku: "单品编码"
          name: "单品名称"
          desc: "单品描述"
          price: "销售价"
          rrp: "市场价"
          weight: "重量(g)"
          qty: "库存"
          seq: "排序"
          free_shipping: "免费配送"
          img: "单品图片"
        cart:
          name: "名称"
          created_at: "创建日期"
        cart_item:
          qty: "数量"
          price: "价格"
          sum: "金额"
        customer:
          name: "姓名"
          email: "电子邮箱"
          password: "密码"
          remember_me: "记住我吗？"
          password_confirmation: "密码确认"
          current_password: "当前密码"
          company: "公司"
          address: "地址"
          province: "省份"
          city: "城市"
          district: "区域"
          postcode: "邮编"
          discount: "折扣"
          customer_group: "客户组"
          ship_name: "收货人姓名"
          ship_company: "收货人单位"
          ship_province: "收货人省份"
          ship_city: "收货人城市"
          ship_district: "收货人地区"
          ship_address: "收货人地址"
          ship_postcode: "收货人邮编"
          telephone: "电话号码"
        supplier:
          name: "供应商名称"
          desc: "描述"
          summary: '摘要'
          actived: "激活"
        employee:
          name: "姓名"
          email: "电子邮箱"
          password: "密码"
          remember_me: "记住我吗？"
          password_confirmation: "密码确认"
          current_password: "当前密码"
          company: "公司"
          address: "地址"
          province: "省份"
          city: "城市"
          district: "区域"
          postcode: "邮编"
          telephone: "电话号码"
        order:
          order_no: "订单号"
          created_at: "创建日期"
          updated_at: "更新日期"
          total: "金额"
          sent: "已提交"
          invoiced: "已开发票"
          paid: "已支付"
          shipped: "已发货"
          desc: "备注"
          ship_name: "收货人姓名"
          ship_company: "收货人单位"
          ship_province: "收货人省份"
          ship_city: "收货人城市"
          ship_district: "收货人地区"
          ship_address: "收货人地址"
          ship_postcode: "收货人邮编"
          ship_email: "收货人邮箱"
          ship_telephone: "收货人电话"
          remark: "备注"
        shipping_method:
          actived: "激活"
          name: "名称"
          desc: "描述"
          cod: "代收"
          seq: "排序"
        shipping_zone:
          actived: "激活"
          name: "名称"
          code: "编码"
          area_codes: "所辖地区"
          seq: "排序"
        shipping_rate:
          shipping_method: "配送方式"
          shipping_zone: "配送区域"
          name: "名称"
          upto: "上限"
          rate: "费用"
        customer_group:
          name: "客户组名称"
          actived: "是否激活"
          discount: "折扣"
        page:
          actived: "激活?"
          code: "标识码"
          title: "标题"
          content: "内容"
          summary: '摘要'
          meta_desc: "页面描述"
          meta_key: "页面关键字"
        article:
          actived: "激活?"
          page: "所属页面"
          title: "标题"
          content: "内容"
          meta_desc: "页面描述"
          meta_key: "页面关键字"
        guest_book:
          name: "姓名"
          email: "邮箱"
          message: "留言"
        review:
          title: "标题"
          content: "评论"
          rating: "等级"
          actived: "状态"
          updated_at: "更新时间"
          reviewer_name: "姓名"
          reviewer_email: "邮箱"
          reviewer_location: "位置"
          product: "产品"
          variant: "版本"


  shopror:
      views:
        category:
          add: '新建分类'
          edit: '编辑分类'
          delete: '删除分类'
          sub_categories: '子分类项'
          no_sub_categories: '此分类下无子分类。'
        product:
          add: '新建商品'
          edit: '编辑商品'
          delete: '删除商品'
          products: '商品列表'
          recent: "最新商品"
          promotion: "促销商品"
          featured: "推荐商品"
          no_products: "无商品项"
          more: '更多...'
          large_view: '浏览大图'
          confirm: "确定删除商品吗？"
        supplier:
          supplier: '供应商'
          country_of_origin: "原产地"
          origin_list: '产地列表'
          add: '新建供应商'
          edit: '编辑供应商'
          delete: '删除供应商'
          list: '供应商列表'
        customer:
          add: '新建客户'
          edit: '编辑客户'
          delete: '删除客户'
          account: '我的帐户'
          no_customers: '没有客户'
          contact_info: "联系信息"
          confirm: "确定删除客户吗？"
          change_detail: "修改个人信息"
          click_here: "单击这里"
          bill_info: "个人信息"
          customer_detail: '客户/会员详细信息'
        employee:
           add: '新建员工'
           edit: '编辑员工'
           delete: '删除员工'
           account: '我的帐户'
           no_customers: '没有员工'
           contact_info: "联系信息"
           confirm: "确定删除员工吗？"
           change_detail: "修改个人信息"
           click_here: "单击这里"
           bill_info: "个人信息"
           detail: '员工详细信息'
        order:
          key: "关键字"
          status: "订单状态"
          recent: "近期"
          history: "历史订单"
          invoice: "发票"
          show: "查看"
          order_status: "订单信息"
          details: "详细信息"
          order_number: "订单编号"
          order_date: "下单时间"
          total: "商品总价(元)"
          price: "单价(元)"
          qty: "数量"
          tax: "税"
          last_update: "确认时间"
          total_order_value: "订单总价"
          shipping: "运费"
          order_total: "总计"
          back: "返回"
          sent_order: "已下单"
          order_payment: "已付款"
          order_invoice: "已开发票"
          order_dispatched: "商品运输中"
          billing_address: "账单地址"
          delivery_address: "配送地址"
          invoice_details: "发票详情"
          customer_name: "客户名称"

        customer_group:
          add: "新建客户组"
          edit: "编辑客户组"
        variant:
          add: "添加商品版本"
          edit: "编缉商品版本"
          delete: "删除商品版本"
          confirm: "确定删除商品版本吗？"
        cart:
          buy: "购买"
          empty: "购物车是空的。"
          del_confirm: "你确定要删除吗？"
          total: "总计"
          recalculate: "重新计算"
          empty_cart: "清空购物车"
          place: "结账"
          checkout: "结账"
          billing_info: "账单信息"
          shipping_info: "配送信息"
          purchaser_contact_info: "联系信息"
          comments: "备注"
          shipping_method: "配送方式"
          show: "查看"
          save: "保存"
          stored: "收藏列表"
          delete: "删除"
          confirm: "你确定要删除吗"
          store_title: "收藏当前购物车内容"
          store: "收藏"
          restore: "恢复"
        shipping:
          management: "配送管理"
          back: "返回配送管理"
        shipping_method:
          add: "新建配送方式"
          edit: "编辑配送方式"
          delete: "删除配送方式"
          confirm: "确定删除配送方式吗？"
        shipping_zone:
          add: "新建配送区域"
          edit: "编辑配送区域"
          delete: "删除配送区域"
          confirm: "确定删除配送区域吗？"
        shipping_rate:
          add: "新建配送费用"
          edit: "编辑配送费用"
          delete: "删除配送费"
          confirm: "确定删除配送费吗？"
        page:
          add: "新建网店页面"
          edit: "编辑网店页面"
          delete: "删除网店页面"
          confirm: "确定删除网店页面吗？"
        article:
          add: "新建网店内容"
          edit: "编辑网店内容"
          delete: "删除网店内容"
          confirm: "确定删除网店内容吗？"
        guest_book:
          contact_us: "联系我们"
          reply: "谢谢.您的留言已发送成功！"
          new: "新建网店留言"
          edit: "编辑网店留言"
          delete: "删除网店留言"
          confirm: "确定删除网店留言吗？"
          add:
            submit: "提交"
        review:
          your_review: "您的评论"
          your_detail: "您的详细信息"
          add: "新增评论"
          edit: "编辑评论"
          delete: "删除评论"
          submit: "提交"
          confirm: "确定删除商品评论吗？"
          waiting_authorisation: "待处理"
          live: "激活"
          diabled: "不可用"
          all_variants: "全部版本"
          no_rating: "没有等级"
        site:
          home: "首页"
          speedorder: "快捷下单"
          guest_book: "客户留言"
          wiki_pages: "商品百科"
          taobao: "淘宝店"
          about: "关于我们"
          my_account: "我的帐户"


      errors:
          messages:
            blank_in_locale:
              "can't be blank in %{location}"
            ambiguous_relationship:
              message: "Ambiguous relations %{candidates} defined on %{klass}."
              summary:
                "When Mongoid attempts to set an inverse document of a relation
                in memory, it needs to know which relation it belongs to. When
                setting %{name}, Mongoid looked on the class %{inverse}
                for a matching relation, but multiples were found that could
                potentially match: %{candidates}."
              resolution: "On the %{name} relation on %{inverse} you must add an
                :inverse_of option to specify the exact relationship on %{klass}
                that is the opposite of %{name}."
            callbacks:
              message: "Calling %{method} on %{klass} resulted in a false return
                from a callback."
              summary: "If a before callback returns false when using Document.create!,
                Document#save!, or Documnet#update_attributes! this error will get raised
                since the document did not actually get saved."
              resolution: "Double check all before callbacks to make sure they are
                not unintentionally returning false."
            calling_document_find_with_nil_is_invalid:
              message: "Calling Document.find with nil is invalid."
              summary: "Document.find expects the parameters to be 1 or more ids, and
                will return a single document if 1 id is provided, otherwise an array
                of documents if multiple ids are provided."
              resolution: "Most likely this is caused by passing parameters directly
                through to the find, and the parameter either is not present or the
                key from which it is accessed is incorrect."
            document_not_found:
              message: "Document(s) not found for class %{klass} with id(s) %{missing}."
              summary: "When calling %{klass}.find with an id or array of ids, each
                parameter must match a document in the database or this error will be
                raised. The search was for the id(s): %{searched} (%{total} total)
                and the following ids were not found: %{missing}."
              resolution: "Search for an id that is in the database or set
                the Mongoid.raise_not_found_error configuration option to false,
                which will cause a nil to be returned instead of raising this error when
                searching for a single id, or only the matched documents when searching
                for multiples."
            document_with_attributes_not_found:
              message: "Document not found for class %{klass} with attributes %{attributes}."
              summary: "When calling %{klass}.find_by with a hash of attributes, all
                attributes provided must match a document in the database or this error
                will be raised."
              resolution: "Search for attributes that are in the database or set
                the Mongoid.raise_not_found_error configuration option to false,
                which will cause a nil to be returned instead of raising this error."
            eager_load:
              message: "Eager loading :%{name} is not supported since it is a
                polymorphic belongs_to relation."
              summary: "Mongoid cannot currently determine the classes it needs to
                eager load when the relation is polymorphic. The parents reside in
                different collections so a simple id lookup is not sufficient enough."
              resolution: "Don't attempt to perform this action and have patience,
                maybe this will be supported in the future."
            invalid_collection:
              message: "Access to the collection for %{klass} is not allowed."
              summary: "%{klass}.collection was called, and %{klass} is an embedded
                document - it resides within the collection of the root document of
                the hierarchy."
              resolution: "For access to the collection that the embedded document is
                in, use %{klass}#_root.collection, or do not attempt to persist an
                embedded document without a parent set."
            invalid_config_option:
              message: "Invalid configuration option: %{name}."
              summary: "A invalid configuration option was provided in your
                mongoid.yml, or a typo is potentially present. The valid configuration
                options are: %{options}."
              resolution: "Remove the invalid option or fix the typo. If you were
                expecting the option to be there, please consult the following page
                with repect to Mongoid's configuration:\n\n
                \_\_http://mongoid.org/en/mongoid/docs/installation.html"
            invalid_field:
              message: "Defining a field named '%{name}' is not allowed."
              summary: "Defining this field would override the method '%{name}',
                which would cause issues with expectations around the original
                method and cause extremely hard to debug issues. The original
                method was defined in:\n
                \_\_Object: %{origin}\n
                \_\_File: %{file}\n
                \_\_Line: %{line}"
              resolution: "Use Mongoid.destructive_fields to see what names are not
                allowed, and don't use these names. These include names that also
                conflict with core Ruby methods on Object, Module, Enumerable, or
                included gems that inject methods into these or Mongoid internals."
            invalid_field_option:
              message: "Invalid option :%{option} provided for field :%{name}."
              summary: "Mongoid requires that you only provide valid options on each
                field definition in order to prevent unexpected behaviour later on."
              resolution: "When defining the field :%{name} on '%{klass}', please provide
                valid options for the field. These are currently: %{valid}. If you
                meant to define a custom field option, please do so first like so:\n\n
                \_\_Mongoid::Fields.option :%{option} do |model, field, value|\n
                \_\_\_\_# Your logic here...\n
                \_\_end\n
                \_\_class %{klass}\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_field :%{name}, %{option}: true\n
                \_\_end\n\n"
            invalid_includes:
              message: "Invalid includes directive: %{klass}.includes(%{args})"
              summary: "Eager loading in Mongoid only supports providing arguments
                to %{klass}.includes that are the names of relations on the %{klass}
                model, and only supports one level of eager loading. (ie, eager loading
                associations not on the %{klass} but one step away via another relation
                is not allowed."
              resolution: "Ensure that each parameter passed to %{klass}.includes is
                a valid name of a relation on the %{klass} model. These are: %{relations}."
            invalid_index:
              message: "Invalid index specification on %{klass}: %{spec}, %{options}"
              summary: "Indexes in Mongoid are defined as a hash of field name and
                direction/2d pairs, with a hash for any additional options."
              resolution: "Ensure that the index conforms to the correct syntax and
                has the correct options.\n\n
                Valid options are:\n
                \_\_background: true|false\n
                \_\_drop_dups: true|false\n
                \_\_name: 'index_name'\n
                \_\_sparse: true|false\n
                \_\_unique: true|false\n
                \_\_min: 1\n
                \_\_max: 1\n
                \_\_bits: 26\n
                \_\_bucket_size : 1\n
                \_\_weights: { content: 1, title: 2 }\n
                Valid types are: 1, -1, '2d', '2dsphere', 'geoHaystack', 'text', 'hashed'\n\n
                Example:\n
                \_\_class Band\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_index({ name: 1, label: -1 }, { sparse: true })\n
                \_\_\_\_index({ location: '2d' }, { background: true })\n
                \_\_end\n\n"
            invalid_options:
              message: "Invalid option :%{invalid} provided to relation :%{name}."
              summary: "Mongoid checks the options that are passed to the relation
                macros to ensure that no ill side effects occur by letting something
                slip by."
              resolution: "Valid options are: %{valid}, make sure these are the ones
                you are using."
            invalid_path:
              message: "Having a root path assigned for %{klass} is invalid."
              summary: "Mongoid has two different path objects for determining
                the location of a document in the database, Root and Embedded.
                This error is raised when an embedded document somehow gets a
                root path assigned."
              resolution: "Most likely your embedded model, %{klass} is also
                referenced via a has_many from a root document in another
                collection. Double check the relation definitions and fix any
                instances where embedded documents are improperly referenced
                from other collections."
            invalid_scope:
              message: "Defining a scope of value %{value} on %{klass} is not
                allowed."
              summary: "Scopes in Mongoid must be either criteria objects or procs
                that wrap criteria objects."
              resolution: "Change the scope to be a criteria or proc wrapped
                critera.\n\n
                Example:\n
                \_\_class Band\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_field :active, type: Boolean, default: true\n
                \_\_\_\_scope :active, where(active: true)\n
                \_\_\_\_scope :inactive, ->{ where(active: false) }\n
                \_\_end\n\n"
            invalid_storage_options:
              message: "Invalid options passed to %{klass}.store_in: %{options}."
              summary: "The :store_in macro takes only a hash of parameters with
                the keys :database, :collection, or :session."
              resolution: "Change the options passed to store_in to match the
                documented API, and ensure all keys in the options hash are
                symbols.\n\n
                Example:\n
                \_\_class Band\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_store_in collection: 'artists', database: 'secondary'\n
                \_\_end\n\n"
            invalid_time:
              message: "'%{value}' is not a valid Time."
              summary: "Mongoid tries to serialize the values for Date, DateTime, and
                Time into proper UTC times to store in the database. The provided
                value could not be parsed."
              resolution: "Make sure to pass parsable values to the field setter
                for Date, DateTime, and Time objects. When this is a String it needs
                to be valid for Time.parse. Other objects must be valid to pass to
                Time.local."
            inverse_not_found:
              message: "When adding a(n) %{klass} to %{base}#%{name}, Mongoid could
                not determine the inverse foreign key to set. The attempted key was
                '%{inverse}'."
              summary: "When adding a document to a relation, Mongoid attempts
                to link the newly added document to the base of the relation in
                memory, as well as set the foreign key to link them on the
                database side. In this case Mongoid could not determine what the
                inverse foreign key was."
              resolution: "If an inverse is not required, like a belongs_to or
                has_and_belongs_to_many, ensure that :inverse_of => nil is set
                on the relation. If the inverse is needed, most likely the
                inverse cannot be figured out from the names of the relations and
                you will need to explicitly tell Mongoid on the relation what
                the inverse is.\n\n
                Example:\n
                \_\_class Lush\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_has_one :whiskey, class_name: \"Drink\", inverse_of: :alcoholic\n
                \_\_end\n\n
                \_\_class Drink\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_belongs_to :alcoholic, class_name: \"Lush\", inverse_of: :whiskey\n
                \_\_end"
            invalid_set_polymorphic_relation:
              message: "The %{name} attribute can't be set to an instance of
                %{other_klass} as %{other_klass} has multiple relations referencing
                %{klass} as %{name}."
              summary: "If the parent class of a polymorphic relation has multiple
                definitions for the same relation, the values must be set from the
                parent side and not the child side since Mongoid cannot determine
                from the child side which relation to go in."
              resolution: "Set the values from the parent, or redefine the relation
                with only a single definition in the parent."
            invalid_value:
              message: "Value of type %{value_class} cannot be written to a field of type %{field_class}"
              summary: "Tried to set a value of type %{value_class} to a field of type %{field_class}"
              resolution: "Verify if the value to be set correspond to field definition"
            mixed_relations:
              message: "Referencing a(n) %{embedded} document from the %{root}
                document via a relational association is not allowed since the
                %{embedded} is embedded."
              summary: "In order to properly access a(n) %{embedded} from %{root}
                the reference would need to go through the root document of
                %{embedded}. In a simple case this would require Mongoid to store
                an extra foreign key for the root, in more complex cases where
                %{embedded} is multiple levels deep a key would need to be stored
                for each parent up the hierarchy."
              resolution: "Consider not embedding %{embedded}, or do the key
                storage and access in a custom manner in the application code."
            mixed_session_configuration:
              message: "Both uri and standard configuration options defined for
                session: '%{name}'."
              summary: "Instead of simply giving uri or standard options a
                preference order, Mongoid assumes that you have made a mistake in
                your configuration and requires that you provide one or the other,
                but not both. The options that were provided were: %{config}."
              resolution: "Provide either only a uri as configuration or only
                standard options."
            nested_attributes_metadata_not_found:
              message: "Could not find metadata for relation '%{name}' on model:
                %{klass}."
              summary: "When defining nested attributes for a relation, Mongoid
                needs to access the metadata for the relation '%{name}' in order
                if add autosave functionality to it, if applicable. Either no
                relation named '%{name}' could be found, or the relation had not
                been defined yet."
              resolution: "Make sure that there is a relation defined named
                '%{name}' on %{klass} or that the relation definition comes before
                the accepts_nested_attributes_for macro in the model - order
                matters so that Mongoid has access to the metadata.\n\n
                Example:\n
                \_\_class Band\n
                \_\_\_\_include Mongoid::Document\n
                \_\_\_\_has_many :albums\n
                \_\_\_\_accepts_nested_attributes_for :albums\n
                \_\_end\n\n"
            no_default_session:
              message: "No default session configuration is defined."
              summary: "The configuration provided settings for: %{keys}, but
                Mongoid requires a :default to be defined at minimum."
              resolution: "If configuring via a mongoid.yml, ensure that within
                your :sessions section a :default session is defined.\n\n
                Example:\n
                \_\_development:\n
                \_\_\_\_sessions:\n
                \_\_\_\_\_\_default:\n
                \_\_\_\_\_\_\_\_hosts:\n
                \_\_\_\_\_\_\_\_\_\_- localhost:27017\n\n"
            no_environment:
              message: "Could not load the configuration since no environment
                was defined."
              summary: "Mongoid attempted to find the appropriate environment
                but no Rails.env, Sinatra::Base.environment, RACK_ENV, or
                MONGOID_ENV could be found."
              resolution: "Make sure some environment is set from the mentioned
                options. Mongoid cannot load configuration from the yaml without
                knowing which environment it is in, and we have considered
                defaulting to development an undesireable side effect of this not
                being defined."
            no_map_reduce_output:
              message: "No output location was specified for the map/reduce
                operation."
              summary: "When executing a map/reduce, you must provide the output
                location of the results. The attempted command was: %{command}."
              resolution: "Provide the location that the output of the operation
                is to go by chaining an #out call to the map/reduce.\n\n
                Example:\n
                \_\_Band.map_reduce(map, reduce).out(inline: 1)\n\n
                Valid options for the out function are:\n
                \_\_inline:  1\n
                \_\_merge:   'collection-name'\n
                \_\_replace: 'collection-name'\n
                \_\_reduce:  'collection-name'\n\n"
            no_metadata:
              message: "Metadata not found for document of type %{klass}."
              summary: "Mongoid sets the metadata of a relation on the document
                when it is either loaded from within the relation, or added to
                one. The presence of the metadata is required in order to
                provide various functionality around relations. Most likely you
                are getting this error because the document is embedded and was
                attempted to be persisted without being associated with a parent,
                or the relation was not properly defined."
              resolution: "Ensure that your relations on the %{klass} model
                are all properly defined, and that the inverse relations
                are also properly defined. Embedded relations must have both the
                parent (embeds_one/embeds_many) and the inverse (embedded_in)
                present in order to work properly."
            no_parent:
              message: "Cannot persist embedded document %{klass} without a
                parent document."
              summary: "If the document is embedded, in order to be persisted it
                must always have a reference to its parent document. This is
                most likely caused by either calling %{klass}.create or
                %{klass}.create! without setting the parent document as an
                attribute."
              resolution: "Ensure that you've set the parent relation if
                instantiating the embedded document direcly, or always create new
                embedded documents via the parent relation."
            no_session_config:
              message: "No configuration could be found for a session named
                '%{name}'."
              summary: "When attempting to create the new session, Mongoid could
                not find a session configuration for the name: '%{name}'. This is
                necessary in order to know the host, port, and options needed
                to connect."
              resolution: "Double check your mongoid.yml to make sure under the
                sessions key that a configuration exists for '%{name}'. If you
                have set the configuration programatically, ensure that '%{name}'
                exists in the configuration hash."
            no_sessions_config:
              message: "No sessions configuration provided."
              summary: "Mongoid's configuration requires that you provide details
                about each session that can be connected to, and requires in
                the sessions config at least 1 default session to exist."
              resolution: "Double check your mongoid.yml to make sure that you
                have a top-level sessions key with at least 1 default session
                configuration for it. You can regenerate a new mongoid.yml for
                assistance via `rails g mongoid:config`.\n\n
                Example:\n
                \_\_development:\n
                \_\_\_\_sessions:\n
                \_\_\_\_\_\_default:\n
                \_\_\_\_\_\_\_\_database: mongoid_dev\n
                \_\_\_\_\_\_\_\_hosts:\n
                \_\_\_\_\_\_\_\_\_\_- localhost:27017\n\n"
            no_session_database:
              message: "No database provided for session configuration: :%{name}."
              summary: "Each session configuration must provide a database so Mongoid
                knows where the default database to persist to. What was provided
                was: %{config}."
              resolution: "If configuring via a mongoid.yml, ensure that within
                your :%{name} section a :database value for the session's default
                database is defined.\n\n
                Example:\n
                \_\_development:\n
                \_\_\_\_sessions:\n
                \_\_\_\_\_\_%{name}:\n
                \_\_\_\_\_\_\_\_database: my_app_db\n
                \_\_\_\_\_\_\_\_hosts:\n
                \_\_\_\_\_\_\_\_\_\_- localhost:27017\n\n"
            no_session_hosts:
              message: "No hosts provided for session configuration: :%{name}."
              summary: "Each session configuration must provide hosts so Mongoid
                knows where the database server is located. What was provided
                was: %{config}."
              resolution: "If configuring via a mongoid.yml, ensure that within
                your :%{name} section a :hosts value for the session hosts is
                defined.\n\n
                Example:\n
                \_\_development:\n
                \_\_\_\_sessions:\n
                \_\_\_\_\_\_%{name}:\n
                \_\_\_\_\_\_\_\_database: my_app_db\n
                \_\_\_\_\_\_\_\_hosts:\n
                \_\_\_\_\_\_\_\_\_\_- localhost:27017\n\n"
            readonly_attribute:
              message: "Attempted to set the readonly attribute '%{name}' with
                the value: %{value}."
              summary: "Attributes flagged as readonly via Model.attr_readonly
                can only have values set when the document is a new record."
              resolution: "Don't define '%{name}' as readonly, or do not attempt
                to update its value after the document is persisted."
            scope_overwrite:
              message: "Cannot create scope :%{scope_name}, because of existing
                method %{model_name}.%{scope_name}."
              summary: "When defining a scope that conflicts with a method that
                already exists on the model, this error will get raised if
                Mongoid.scope_overwrite_exception is set to true."
              resolution: "Change the name of the scope so it does not conflict
                with the already defined method %{model_name}, or set the
                configuration option Mongoid.scope_overwrite_exception to false,
                which is its default. In this case a warning will be logged."
            taken:
              "已被使用"
            too_many_nested_attribute_records:
              message: "Accepting nested attributes for %{association} is limited
                to %{limit} records."
              summary: "More documents were sent to be processed than the allowed
                limit."
              resolution: "The limit is set as an option to the macro, for example:
                accepts_nested_attributes_for :%{association}, limit: %{limit}.
                Consider raising this limit or making sure no more are sent than
                the set value."
            unknown_attribute:
              message: "Attempted to set a value for '%{name}' which is not
                allowed on the model %{klass}."
              summary: "Without including Mongoid::Attributes::Dynamic in your model
                and the attribute does not already exist in the attributes hash,
                attempting to call %{klass}#%{name}= for it is not allowed. This is
                also triggered by passing the attribute to any method that accepts an
                attributes hash, and is raised instead of getting a NoMethodError."
              resolution: "You can include Mongoid::Attributes::Dynamic if you
                expect to be writing values for undefined fields often."
            unsaved_document:
              message: "Attempted to save %{document} before the parent %{base}."
              summary: "You cannot call create or create! through the
                relation (%{document}) who's parent (%{base}) is
                not already saved. This would case the database to be out of sync
                since the child could potentially reference a nonexistant parent."
              resolution: "Make sure to only use create or create! when the parent
                document %{base} is persisted."
            unsupported_javascript:
              message: "Executing Javascript $where selector on an embedded criteria
                is not supported."
              summary: "Mongoid only supports providing a hash of arguments to
                #where criterion on embedded documents. Since %{klass} is embedded,
                the expression %{javascript} is not allowed."
              resolution: "Please provide a standard hash to #where when the criteria
                is for an embedded relation."
            validations:
              message: "Validation of %{document} failed."
              summary: "The following errors were found: %{errors}"
              resolution: "Try persisting the document with valid data or remove
                the validations."
            delete_restriction:
              message: "Cannot delete %{document} because of dependent '%{relation}'."
              summary: "When defining '%{relation}' with a :dependent => :restrict,
                Mongoid will raise an error when attempting to delete the
                %{document} when the child '%{relation}' still has documents in it."
              resolution: "Don't attempt to delete the parent %{document} when
                it has children, or change the dependent option on the relation."